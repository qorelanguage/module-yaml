# -*- mode: qore; indent-tabs-mode: nil -*-
# @file DataStreamClient.qm Qore user module implementing client support for the DataStream protocol: YAML-encoded HTTP chunked transfers where each chunk is a unique data entity

/*  DataStreamClient.qm Copyright (C) 2014 - 2022 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum Qore version
%requires qore >= 1.7.3

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

%requires DataStreamUtil
%requires RestClient >= 1.4
%requires yaml
%requires Mime

# do not use $ signs in declarations
%new-style

module DataStreamClient {
    version = "1.2";
    desc = "user module implementing client support for the DataStream protocol: YAML-encoded HTTP chunked transfers where each chunk is a unique data entity";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/*  Version History: see docs below
*/

/** @mainpage DataStreamClient Module

    @tableofcontents

    @section datastreamclientintro Introduction to the DataStreamClient Module

    The %DataStreamClient module provides client support for the @ref datastreamprotocol "DataStream protocol": YAML-encoded HTTP chunked transfers where each chunk is a unique data entity.

    In %Qore, DataStream support is implemented on top of the REST infrastructure provided by the %Qore library; in this module, the @ref DataStreamClient::DataStreamClient "DataStreamClient" class inherits and extends RestClient for this reason.

    To use this module, use \c "%requires DataStreamClient" in your code.

    All the public symbols in the module are defined in the DataStreamClient namespace

    Classes:
    - @ref DataStreamClient::DataStreamClient "DataStreamClient"
    - @ref DataStreamClient::DataStreamRecvMessage "DataStreamRecvMessage"
    - @ref DataStreamClient::DataStreamSendMessage "DataStreamSendMessage"
    - @ref DataStreamClient::DataStreamMessage "DataStreamRecvMessage"

    @note Most of the underlying functionality is provided by the @ref datastreamutilintro "DataStreamUtil" module

    @section datastreamclientrelnotes Release Notes

    @subsection datastreamclient_v1_2 DataStreamClient v1.2
    - fixed a bug where the \c "response-code" key of the output info hash could be missing in some cases
      (<a href="https://github.com/qorelanguage/qore/issues/3237">issue 3237</a>)

    @subsection datastreamclient_v1_1 DataStreamClient v1.1
    - updated for internal RestClient API changes related to REST schema validation (<a href="https://github.com/qorelanguage/qore/issues/2072">issue 2072</a>)

    @subsection datastreamclient_v1_0_1 DataStreamClient v1.0.1
    - fixed bugs handling chunked non-DataStream messages (<a href="https://github.com/qorelanguage/qore/issues/1438">issue 1438</a>)

    @subsection datastreamclient_v1_0 DataStreamClient v1.0
    - initial release of the module
*/

#! the DataStreamClient namespace contains all the public objects in the DataStreamClient module
public namespace DataStreamClient {
    #! this class can be used to send and receive data using the @ref datastreamprotocol "DataStream protocol"
    public class DataStreamSendMessage {
        public {}

        #! this method returns data to be returned to the server; when this method returns no value, it signifies the end of the streamed data transfer; this method calls sendDataImpl() to return the data
        /** @return the data returned by this callback will be serialized to YAML and send via the @ref datastreamprotocol "DataStream protocol" to the remote HTTP REST server in HTTP chunked format; when all data has been send then this callback should return @ref nothing, which will close the chunked message and terminate the request
        */
        auto sendData() {
            return sendDataImpl();
        }

        #! reimplement this method in subclasses to support streamed data transfers; when this method returns no value, it signifies the end of the streamed data transfer
        /** @return the data returned by this callback will be serialized to YAML and send via the @ref datastreamprotocol "DataStream protocol" to the remote HTTP REST server in HTTP chunked format; when all data has been send then this callback should return @ref nothing, which will close the chunked message and terminate the request
        */
        private abstract auto sendDataImpl();
    }

    #! this class can be used to send and receive data using the @ref datastreamprotocol "DataStream protocol"
    public class DataStreamRecvMessage {
        public {
            # any datastream error received from the remote end
            string err;
        }

        #! receives decoded data from the remote end and calls recvDataImpl()
        /** @param data the argument passed to this callback is the decoded and deserialized data in the message
        */
        nothing recvData(auto data) {
            recvDataImpl(data);
        }

        #! this method is called when all data has been received; this method calls recvDataDoneImpl()
        /** @param err this argument is @ref nothing the sender does not report a send error, otherwise it's a single string giving the send error reported by the sending side in the \c DataStream-Error trailer record
        */
        nothing recvDataDone(*string err) {
            recvDataDoneImpl(err);
        }

        #! this method is called when all data has been received
        /** @param err this argument is @ref nothing the sender does not report a send error, otherwise it's a single string giving the send error reported by the sending side in the \c DataStream-Error trailer record
        */
        private nothing recvDataDoneImpl(*string err) {
        }

        #! reimplement this method in subclasses to receive decoded and deserialized data
        /** @param data the argument passed to this callback is the decoded and deserialized data in the message
        */
        private abstract nothing recvDataImpl(auto data);
    }

    #! this class can be used to send and receive data using the @ref datastreamprotocol "DataStream protocol"
    public class DataStreamMessage inherits DataStreamSendMessage, DataStreamRecvMessage {
    }

    #! this class extends @ref RestClient::RestClient "RestClient" with support for the @ref datastreamprotocol "DataStream protocol"
    public class DataStreamClient inherits RestClient::RestClient {
        public {
            #! DataStreamClient Version
            const Version = "1.1";

            #! DataStreamClient Version String
            const VersionString = sprintf("Qore-DataStreamClient/%s", DataStreamClient::Version);

            #! default HTTP headers
            const DefaultHeaders = RestClient::DefaultHeaders + {
                "User-Agent": DataStreamClient::VersionString,
                DataStreamAccept: MimeTypeYaml,
            };
        }

        #! calls the base class RestClient constructor and optionally connects to the REST server
        /** @par Example:
            @code{.py}
DataStreamClient ds(("url": "http://localhost:8001/rest"));
            @endcode

            @param opts valid options are:
            - \c connect_timeout: The timeout value in milliseconds for establishing a new socket connection (also can be a relative date-time value for clarity, ex: \c 20s)
            - \c default_path: The default path to use for new connections if a path is not otherwise specified in the connection URL
            - \c default_port: The default port number to connect to if none is given in the URL
            - \c headers: an optional hash of headers to send with every request, these can also be overridden in request method calls
            - \c http_version: Either '1.0' or '1.1' for the claimed HTTP protocol version compliancy in outgoing message headers
            - \c max_redirects: The maximum number of redirects before throwing an exception (the default is 5)
            - \c proxy: The proxy URL for connecting through a proxy
            - \c timeout: The timeout value in milliseconds (also can be a relative date-time value for clarity, ex: \c 30s)
            - \c url: A string giving the URL to connect to
            @param do_not_connect if \c False (the default), then a connection will be immediately established to the remote server

            @throw RESTCLIENT-ERROR invalid option passed to constructor, unsupported data serialization, etc

            @note the \c data argument to @ref RestClient::RestClient::constructor() "RestClient::constructor()" is set to \c "yaml" automatically
        */
        constructor(*hash<auto> opts, *softbool do_not_connect) : RestClient(opts + ("data": "yaml"), do_not_connect) {
            # build default DataStream-Accept-Encoding header from Accept-Encoding header if present
            hash<auto> dh = DefaultHeaders;
            if (headers."Accept-Encoding") {
                *string dae = ds_get_ds_accept_enc_header(headers."Accept-Encoding");
                if (dae)
                    dh{DataStreamAcceptEncoding} = dae;
            } else
                dh{DataStreamAcceptEncoding} = "gzip,bzip2,deflate";
            headers = dh + opts.headers;
        }

        #! sends an HTTP request to an HTTP REST server supporting the @ref datastreamprotocol "DataStream protocol" and returns the decoded and deserialized response in the given callback as each HTTP chunk is received
        /** @par Example:
            @code{.py}
rest.recvDataStream(recvcallback, endcallback, "GET", "/orders/1", body);
            @endcode

            @param recv_callback The receive callback for the data received; the argument passed to this callback is the decoded and deserialized data in the message
            @param eod_callback When the chunked transfer has completed; this must accept a @ref string_or_nothing "*string" argument; this is called with no arguments once all data has been received if the sender does not report a send error, otherwise it's called with a single string giving the send error reported by the sending side in the \c DataStream-Error trailer record
            @param method the HTTP method to be used; case is ignored (if not a valid method an \c HTTP-CLIENT-METHOD-ERROR exception is raised)
            @param path the URI path to add (will be appended to any root path given in the constructor)
            @param body an optional message body to be included in the request; if a value for this parameter is passed to the method, then the body will be serialized with YAML serialization
            @param timeout_ms the timeout in milliseconds for the socket I/O operations; 0 means use the default timeout value
            @param info an optional reference to a hash that will be used as an output variable giving a hash of request headers and other information about the HTTP request
            @param hdr any headers to be sent with the request; headers here will override default headers for the object as well

            @throw HTTP-CLIENT-METHOD-ERROR invalid/unknown HTTP method passed
            @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
            @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
            @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 100 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash equal to the normal return value of this method including a \c "status_code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
            @throw ENCODING-CONVERSION-ERROR the given string could not be converted to the socket's character encoding
            @throw SOCKET-SEND-ERROR There was an error sending the data
            @throw SOCKET-CLOSED The remote end closed the connection
            @throw SOCKET-RECV-ERROR There was an error receiving the data
            @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
            @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
            @throw SOCKET-HTTP-ERROR Invalid HTTP data was received
            @throw DESERIALIZATION-ERROR the response body could not be deserialized (unknown \c Content-Type or invalid serialization)

            @note this method can also be used if the server returns a non-chunked response; the response body will be decoded, deserialized, and passed to the receive callback as if a chunked body were received, additionally the terminating call with no arguments is also made to signal the end of the chunked data
         */
        recvDataStream(code recv_callback, code eod_callback, string method, string path, auto body, timeout timeout_ms = 0, *reference<hash<auto>> info, *hash<auto> hdr) {
            prepareMsg(method, path, \body, \hdr);

            on_exit if (exists body) {
                info += {
                    "request-body": body,
                    "request-serialization": ds,
                };
            }

            # prepare path
            preparePath(\path);

            sendWithRecvCallback(ds_get_recv(recv_callback, eod_callback), body, method, path, hdr, timeout_ms, False, \info);
        }

        #! sends an HTTP request to an HTTP REST server supporting the @ref datastreamprotocol "DataStream protocol" and returns the decoded and deserialized response in the given callback as each HTTP chunk is received
        /** @par Example:
            @code{.py}
rest.recvDataStream(reccallback, "GET", "/orders/1", body);
            @endcode

            @param dsm the @ref DataStreamRecvMessage object providing the DataStreamRecvMessage::recvData() and DataStreamRecvMessage::recvDataDone() methods to be used as callbacks
            @param method the HTTP method to be used; case is ignored (if not a valid method an \c HTTP-CLIENT-METHOD-ERROR exception is raised)
            @param path the URI path to add (will be appended to any root path given in the constructor)
            @param body an optional message body to be included in the request; if a value for this parameter is passed to the method, then the body will be serialized with YAML serialization
            @param timeout_ms the timeout in milliseconds for the socket I/O operations; 0 means use the default timeout value
            @param info an optional reference to a hash that will be used as an output variable giving a hash of request headers and other information about the HTTP request
            @param hdr any headers to be sent with the request; headers here will override default headers for the object as well

            @throw HTTP-CLIENT-METHOD-ERROR invalid/unknown HTTP method passed
            @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
            @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
            @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 100 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash equal to the normal return value of this method including a \c "status_code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
            @throw ENCODING-CONVERSION-ERROR the given string could not be converted to the socket's character encoding
            @throw SOCKET-SEND-ERROR There was an error sending the data
            @throw SOCKET-CLOSED The remote end closed the connection
            @throw SOCKET-RECV-ERROR There was an error receiving the data
            @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
            @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
            @throw SOCKET-HTTP-ERROR Invalid HTTP data was received
            @throw DESERIALIZATION-ERROR the response body could not be deserialized (unknown \c Content-Type or invalid serialization)

            @note this method can also be used if the server returns a non-chunked response; the response body will be decoded, deserialized, and passed to the receive callback as if a chunked body were received, additionally the terminating call with no arguments is also made to signal the end of the chunked data
         */
        recvDataStream(DataStreamRecvMessage dsm, string method, string path, auto body, timeout timeout_ms = 0, *reference<hash<auto>> info, *hash<auto> hdr) {
            recvDataStream(\dsm.recvData(), \dsm.recvDataDone(), method, path, body, timeout_ms, \info, hdr);
        }

        #! Sends an HTTP request to an HTTP REST server supporting the @ref datastreamprotocol "DataStream protocol" with the specified method and chunked message body as given by a send callback and returns the deserialized body and response headers received as a response
        /** If a connection has not already been established, an internal call to HTTPClient::connect() will be made before sending the message

            @par Example:
            @code{.py}
hash h = rest.sendDataStream(callback, "POST", "/path");
            @endcode

            @param scb The callback giving the chunked HTTP data to send; the data returned by this callback will be serialized to YAML and send via the @ref datastreamprotocol "DataStream protocol" to the remote HTTP REST server in HTTP chunked format; when all data has been send then this callback should return @ref nothing, which will close the chunked message and terminate the request
            @param method The name of the HTTP method (\c "GET", \c "POST", \c "HEAD", \c "OPTIONS", \c "PUT", \c "DELETE", \c "TRACE", or \c "CONNECT").
            @param path the URI path to add (will be appended to any root path given in the constructor)
            @param timeout_ms the timeout in milliseconds for the socket I/O operations; 0 means use the default timeout value
            @param info An optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request
            @param hdr any headers to be sent with the request; headers here will override default headers for the object as well

            @return The headers received from the HTTP server with all key names converted to lower-case. The message body (if any) will be decoded and deserialized and assigned to the value of the \c "body" key, and the HTTP status will be assigned to the \c "status_code" key.  In the case of a chunked DataStream response, the \c "body" key will be assigned a list where each list element is the data value of the respective DataStream chunk

            @throw HTTP-CLIENT-METHOD-ERROR invalid/unknown HTTP method passed
            @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
            @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
            @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 100 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash equal to the normal return value of this method including a \c "status_code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
            @throw ENCODING-CONVERSION-ERROR the given string could not be converted to the socket's character encoding
            @throw SOCKET-SEND-ERROR There was an error sending the data
            @throw SOCKET-CLOSED The remote end closed the connection
            @throw SOCKET-RECV-ERROR There was an error receiving the data
            @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
            @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
            @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

            @note
            - The \c "Transfer-Encoding: chunked" header is automatically set with this method if no \c "Transfer-Encoding" header is already present
            - For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)
            - this method can also be used when the server returns chunked @ref datastreamprotocol "DataStream protocol" data; in this case the chunked response is received in its entirity and returns in the return value's \c "body" key as a list where each list element is the data value of the respective DataStream chunk
            - the value of the return value's \c "body" key will be decoded and deserialized data
        */
        hash<auto> sendDataStream(code scb, string method, string path, timeout timeout_ms = 0, *reference<hash<auto>> info, *hash<auto> hdr) {
            hdr = headers + hdr;

            ds_set_chunked_headers(\hdr, seh.ce, True);

            # prepare path
            preparePath(\path);

            /* we cannot just receive standard HTTP chunked data here since any Content-Encoding will not be respected,
             * and any DataStream content encoding can only be applied to each chunk separately.  Therefore we have
             * to intercept the chunked messages here to build the respose data and also capture the headers
             * returned
             */

            # received data
            auto rmd;
            # chunked response flag (determines if rmd is a list or not)
            bool chunked;
            # define data callback to build response msg data
            code recv_data_callback = sub (auto d) {
                if (exists d) {
                    if (chunked) {
                        if (!rmd)
                            rmd = ();
                        rmd += d;
                    }
                    else
                        rmd = d;
                }
            };
            code eod_callback = sub () {};
            # get DataStream receive callback using our local data callback closure
            code dsrecv_callback = ds_get_recv(recv_data_callback, eod_callback);
            # save response header
            hash<auto> rhdr;
            # send aborted flag
            bool send_aborted;
            # our top-level receive callback to save the header and set the chunked flag
            code recv_callback = sub (hash<auto> h) {
                if (h.hdr) {
                    rhdr = h.hdr;
                    if (h.hdr."transfer-encoding" == "chunked")
                        chunked = True;
                    else if (h.send_aborted)
                        send_aborted = True;
                }
                # call DataStream callback
                dsrecv_callback(h);
            };

            sendWithCallbacks(ds_get_send(scb, seh.func), recv_callback, method, path, hdr, timeout_ms, False, \info);

            # rethrow exceptions returned from the sender
            if (rhdr.status_code >= 300 && rmd.err && rmd.desc) {
                throw rmd.err, rmd.desc, rmd.arg;
            }

            if (send_aborted) {
                throw "SEND-ABORTED", sprintf("receiver returned status code %d while sending chunked data; send was "
                    "aborted", rhdr.status_code), ("hdr": rhdr, "data": rmd);
            }

            return rhdr + ("body": rmd);
        }

        #! Sends an HTTP request to an HTTP REST server supporting the @ref datastreamprotocol "DataStream protocol" with the specified method and chunked message body as given by a send callback and returns the deserialized body and response headers received as a response
        /** If a connection has not already been established, an internal call to HTTPClient::connect() will be made before sending the message

            @par Example:
            @code{.py}
hash<auto> h = rest.sendDataStream(callback, "POST", "/path");
            @endcode

            @param dsm the @ref DataStreamSendMessage object providing the DataStreamSendMessage::sendData() method to be used as a callback
            @param method The name of the HTTP method (\c "GET", \c "POST", \c "HEAD", \c "OPTIONS", \c "PUT", \c "DELETE", \c "TRACE", or \c "CONNECT").
            @param path the URI path to add (will be appended to any root path given in the constructor)
            @param timeout_ms the timeout in milliseconds for the socket I/O operations; 0 means use the default timeout value
            @param info An optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request
            @param hdr any headers to be sent with the request; headers here will override default headers for the object as well

            @return The headers received from the HTTP server with all key names converted to lower-case. The message body (if any) will be decoded and deserialized and assigned to the value of the \c "body" key, and the HTTP status will be assigned to the \c "status_code" key.  In the case of a chunked DataStream response, the \c "body" key will be assigned a list where each list element is the data value of the respective DataStream chunk

            @throw HTTP-CLIENT-METHOD-ERROR invalid/unknown HTTP method passed
            @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
            @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
            @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 100 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash equal to the normal return value of this method including a \c "status_code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
            @throw ENCODING-CONVERSION-ERROR the given string could not be converted to the socket's character encoding
            @throw SOCKET-SEND-ERROR There was an error sending the data
            @throw SOCKET-CLOSED The remote end closed the connection
            @throw SOCKET-RECV-ERROR There was an error receiving the data
            @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
            @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
            @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

            @note
            - The \c "Transfer-Encoding: chunked" header is automatically set with this method if no \c "Transfer-Encoding" header is already present
            - For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)
            - this method can also be used when the server returns chunked @ref datastreamprotocol "DataStream protocol" data; in this case the chunked response is received in its entirity and returns in the return value's \c "body" key as a list where each list element is the data value of the respective DataStream chunk
            - the value of the return value's \c "body" key will be decoded and deserialized data
        */
        hash<auto> sendDataStream(DataStreamSendMessage dsm, string method, string path, timeout timeout_ms = 0, *reference<hash<auto>> info, *hash<auto> hdr) {
            return sendDataStream(\dsm.sendData(), method, path, timeout_ms, \info, hdr);
        }

        #! Sends an HTTP request an HTTP REST server supporting the @ref datastreamprotocol "DataStream protocol" with the specified method and serialized and encoded chunked message body as given by a send callback; decoded and deserialized data received from the HTTP server are returned through a receive callback
        /** This method is useful for sending streaming data in the request and where streaming data is also expected in the response.

            If a connection has not already been established, an internal call to HTTPClient::connect() will be made before sending the message

            @par Example:
            @code{.py}
rest.sendRecvDataStream(send_callback, reccallback, "POST", "/path");
            @endcode

            @param scb The callback giving the chunked HTTP data to send; the data returned by this callback will be serialized to YAML and send via the @ref datastreamprotocol "DataStream protocol" to the remote HTTP REST server in HTTP chunked format; when all data has been send then this callback should return @ref nothing, which will close the chunked message and terminate the request
            @param recv_callback The receive callback for the data received; the argument passed to this callback is the decoded and deserialized data in the message
            @param eod_callback When the chunked transfer has completed; this must accept a @ref string_or_nothing "*string" argument; this is called with no arguments once all data has been received if the sender does not report a send error, otherwise it's called with a single string giving the send error reported by the sending side in the \c DataStream-Error trailer record
            @param method The name of the HTTP method (\c "GET", \c "POST", \c "HEAD", \c "OPTIONS", \c "PUT", \c "DELETE", \c "TRACE", or \c "CONNECT").
            @param path The path for the message (i.e. \c "/path/resource?method&param=value")
            @param timeout_ms the timeout in milliseconds for the socket I/O operations; 0 means use the default timeout value
            @param info An optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request.
            @param hdr any headers to be sent with the request; headers here will override default headers for the object as well

            @throw HTTP-CLIENT-METHOD-ERROR invalid/unknown HTTP method passed
            @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
            @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
            @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 100 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash equal to the normal return value of this method including a \c "status_code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
            @throw ENCODING-CONVERSION-ERROR the given string could not be converted to the socket's character encoding
            @throw SOCKET-SEND-ERROR There was an error sending the data
            @throw SOCKET-CLOSED The remote end closed the connection
            @throw SOCKET-RECV-ERROR There was an error receiving the data
            @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
            @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
            @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

            @note
            - The \c "Transfer-Encoding: chunked" header is automatically set with this method if no \c "Transfer-Encoding" header is already present
            - For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)

            @note this method can also be used if the server returns a non-chunked response; the response body will be decoded, deserialized, and passed to the receive callback as if a chunked body were received, additionally the terminating call with no arguments is also made to signal the end of the chunked data
        */
        sendRecvDataStream(code scb, code recv_callback, code eod_callback, string method, string path,
                timeout timeout_ms = 0,
                *reference<hash<auto>> info, *hash<auto> hdr) {
            hdr = headers + hdr;

            ds_set_chunked_headers(\hdr, seh.ce, True);

            # prepare path
            preparePath(\path);

            sendWithCallbacks(ds_get_send(scb, seh.func), ds_get_recv(recv_callback, eod_callback), method, path, hdr,
                timeout_ms, False, \info);
        }

        #! Sends an HTTP request an HTTP REST server supporting the @ref datastreamprotocol "DataStream protocol" with the specified method and serialized and encoded chunked message body as given by a send callback; decoded and deserialized data received from the HTTP server are returned through a receive callback
        /** This method is useful for sending streaming data in the request and where streaming data is also expected in the response.

            If a connection has not already been established, an internal call to HTTPClient::connect() will be made before sending the message

            @par Example:
            @code{.py}
rest.sendRecvDataStream(send_callback, reccallback, "POST", "/path");
            @endcode

            @param dsm the @ref DataStreamMessage object providing the DataStreamMessage::sendData(), DataStreamMessage::recvData(), and DataStreamMessage::recvDataDone() methods method to be used as callbacks
            @param method The name of the HTTP method (\c "GET", \c "POST", \c "HEAD", \c "OPTIONS", \c "PUT", \c "DELETE", \c "TRACE", or \c "CONNECT").
            @param path The path for the message (i.e. \c "/path/resource?method&param=value")
            @param timeout_ms the timeout in milliseconds for the socket I/O operations; 0 means use the default timeout value
            @param info An optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request.
            @param hdr any headers to be sent with the request; headers here will override default headers for the object as well

            @throw HTTP-CLIENT-METHOD-ERROR invalid/unknown HTTP method passed
            @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
            @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
            @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 100 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash equal to the normal return value of this method including a \c "status_code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
            @throw ENCODING-CONVERSION-ERROR the given string could not be converted to the socket's character encoding
            @throw SOCKET-SEND-ERROR There was an error sending the data
            @throw SOCKET-CLOSED The remote end closed the connection
            @throw SOCKET-RECV-ERROR There was an error receiving the data
            @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
            @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
            @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

            @note
            - The \c "Transfer-Encoding: chunked" header is automatically set with this method if no \c "Transfer-Encoding" header is already present
            - For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)

            @note this method can also be used if the server returns a non-chunked response; the response body will be decoded, deserialized, and passed to the receive callback as if a chunked body were received, additionally the terminating call with no arguments is also made to signal the end of the chunked data
        */
        sendRecvDataStream(DataStreamMessage dsm, string method, string path, timeout timeout_ms = 0,
                *reference<hash<auto>> info, *hash<auto> hdr) {
            sendRecvDataStream(\dsm.sendData(), \dsm.recvData(), \dsm.recvDataDone(), method, path, timeout_ms, \info,
                hdr);
        }

        #! send raw chunked data to the client and expect a YAML-formatted response
        /** @par Example:
            @code{.py}
hash<auto> h = rest.sendRawStream(sender, "POST", uri_path, 20s);
            @endcode

            The request will be made with the \c "Accept" header set to \c "application/x-yaml"; replies are expected to be YAML-serialized data.  Note that the \c "body" key in the return value will contain the deserialized YAML payload as Qore data.

            @param scb The callback giving the chunked HTTP data to send; this callback must return either a string or a binary value each time it is called to give the chunked data to send; when all data has been sent, then a hash of message trailers can be sent or simply @ref nothing which will close the chunked message
            @param method The name of the HTTP method (\c "GET", \c "POST", \c "HEAD", \c "OPTIONS", \c "PUT", \c "DELETE", \c "TRACE", or \c "CONNECT").
            @param path The path for the message (i.e. \c "/path/resource?method&param=value")
            @param timeout_ms the timeout in milliseconds for the socket I/O operations; 0 means use the default timeout value
            @param info An optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request.
            @param hdr any headers to be sent with the request; headers here will override default headers for the object as well

            @return The headers received from the HTTP server with all key names converted to lower-case. The deserialized YAML message body (if any) will be assigned to the value of the \c "body" key and the HTTP status will be assigned to the \c "status_code" key.

            @throw HTTP-CLIENT-METHOD-ERROR invalid/unknown HTTP method passed
            @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
            @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
            @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 100 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash equal to the normal return value of this method including a \c "status_code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
            @throw ENCODING-CONVERSION-ERROR the given string could not be converted to the socket's character encoding
            @throw SOCKET-SEND-ERROR There was an error sending the data
            @throw SOCKET-CLOSED The remote end closed the connection
            @throw SOCKET-RECV-ERROR There was an error receiving the data
            @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
            @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
            @throw SOCKET-HTTP-ERROR Invalid HTTP data was received
        */
        hash<auto> sendRawStream(code scb, string method, *string path, timeout timeout_ms = 0,
                *reference<hash<auto>> info, *hash<auto> hdr) {
            if (!hdr.Accept)
                hdr.Accept = MimeTypeYaml;
            hash<auto> h = sendWithSendCallback(scb, method, path, hdr, timeout_ms, False, \info);
            if (h."content-type" == MimeTypeYaml && h.body)
                h.body = parse_yaml(h.body);
            return h;
        }

        #! receives raw chunked data using the given closure and returns any headers received
        /** @par Example:
            @code{.py}
hash<auto> h = rest.getRawStream(recv, "GET", uri_path, 20s);
            @endcode

            Any message body will be serialized as YAML and the \c "Content-Type" header will be set to \c "application/x-yaml".

            @param recv_callback The receive callback for the data received; first this method is called with a hash of the message headers, and then with any message body; if a chunked HTTP message is received, then the callback is called once for each chunk; when the message has been received, then the receive callback is called with a hash representing any trailer data received in a chunked transfer or @ref nothing if the data was received in a normal message body or if there was no trailer data in a chunked transfer.  The argument to this callback is always a hash; data calls have the following keys:
            - \c "data": the string or binary data
            - \c "chunked": True if the data was received with chunked transfer encoding, False if not
            .
            Header or trailer data is placed in a hash with the following keys:
            - \c "hdr": this can be assigned to @ref nothing for the trailer hash if the data was not sent chunked or no trailers were included in a chunked message
            - \c "obj": this is the owning object (so socket parameters can be changed based on headers received, such as, for example, socket character encoding)
            @param method The name of the HTTP method (\c "GET", \c "POST", \c "HEAD", \c "OPTIONS", \c "PUT", \c "DELETE", \c "TRACE", or \c "CONNECT"). Additional methods can be added in the constructor as a \c additional_methods option.
            @param path The path for the message (i.e. \c "/path/resource?method&param=value")
            @param body an optional message body to be included in the request; if a value for this parameter is passed to the method, then the body will be serialized with YAML serialization
            @param timeout_ms the timeout in milliseconds for the socket I/O operations; 0 means use the default timeout value
            @param info An optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request.
            @param hdr An optional hash of headers to include in the message.

            @throw HTTP-CLIENT-METHOD-ERROR invalid/unknown HTTP method passed
            @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
            @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
            @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 100 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash equal to the normal return value of this method including a \c "status_code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
            @throw ENCODING-CONVERSION-ERROR the given string could not be converted to the socket's character encoding
            @throw SOCKET-SEND-ERROR There was an error sending the data
            @throw SOCKET-CLOSED The remote end closed the connection
            @throw SOCKET-RECV-ERROR There was an error receiving the data
            @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
            @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
            @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

            @note For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)
        */
        hash<auto> getRawStream(code recv_callback, string method, *string path, auto body, timeout timeout_ms = 0,
                *reference<hash<auto>> info, *hash<auto> hdr) {
            hash<auto> rvhdr;
            code mrecv_callback = sub (hash<auto> h) {
                if (h.hdr && !rvhdr)
                    rvhdr = h.hdr;
                recv_callback(h);
            };
            if (exists body) {
                body = make_yaml(body);
                hdr."Content-Type" = MimeTypeYaml;
            }
            sendWithRecvCallback(mrecv_callback, body, method, path, hdr, timeout_ms, False, \info);
            return rvhdr;
        }

        #! adds default headers to each request; these headers will be sent in all requests but can be overridden in requests as well
        /** @par Example:
            @code{.py}
# disable gzip and bzip encoding in responses
rest.addDefaultHeaders(("Accept-Encoding": "compress"));
            @endcode

            @param h a hash of headers to add to the default headers to send on each request

            @note default headers can also be set in the constructor

            @see @ref RestClient::RestClient::getDefaultHeaders() "RestClient::getDefaultHeaders()"
        */
        addDefaultHeaders(hash<auto> h) {
            headers += h;
            if (h."Accept-Encoding")
                headers{DataStreamAcceptEncoding} = ds_get_ds_accept_enc_header(h."Accept-Encoding");
        }

        #! sets the request and desired response encoding for the object; see @ref EncodingSupport for valid options
        /** @par Example:
            @code{.py}
rest.setContentEncoding("gzip");
            @endcode

            @param enc the data content encoding (compression) option for requests and the desired response content encoding for the object; see @ref EncodingSupport for valid options; if the value \c "auto" is passed then \c "gzip" encoding is used for outgoing requests and requested for responses

            @throw RESTCLIENT-ERROR invalid or unsupported data content encoding / compression option
        */
        setContentEncoding(string enc = "auto") {
            RestClient::setContentEncoding(enc);
            headers{DataStreamAcceptEncoding} = headers."Accept-Encoding";
        }

        #! sets up headers and encodes any body for sending
        private nothing prepareMsg(string method, string path, reference<auto> body, reference<hash<auto>> hdr,
                string ct = "Content-Type") {
            RestClient::prepareMsg(method, path, \body, \hdr, ct);
            ds_set_non_chunked_headers(\hdr, seh.ce, True);
        }

        #! sends the outgoing HTTP message and recodes the response to data
        hash<auto> sendAndDecodeResponse(*data body, string m, string path, hash<auto> hdr,
                *reference<hash<auto>> info, *softbool decode_errors) {
            /* we cannot just receive standard HTTP chunked data here since any Content-Encoding will not be
               respected, and any DataStream content encoding can only be applied to each chunk separately.  Therefore
               we have to intercept the chunked messages here to build the respose data and also capture the headers
               returned
            */
            # received data
            auto rmd;
            # chunked response flag (determines if rmd is a list or not)
            bool chunked;
            # define data callback to build response msg data
            code recv_data_callback = sub (auto d) {
                if (exists d) {
                    if (chunked) {
                        if (!rmd) {
                            rmd = ();
                        }
                        rmd += d;
                    } else {
                        rmd = d;
                    }
                }
            };
            code eod_callback = sub () {};
            # response serialization
            string rs;
            # raw response
            data rrs;
            on_exit info += {
                "response-body": rrs,
                "response-serialization": rs,
            };
            code body_callback = sub (auto b, string code) {
                rrs += b;
                rs = code;
            };
            # get DataStream receive callback using our local data callback closure
            code dsrecv_callback = ds_get_recv(recv_data_callback, eod_callback, body_callback);
            # save response header
            hash<auto> rhdr;
            # send aborted flag
            bool send_aborted;
            # our top-level receive callback to save the header and set the chunked flag
            code recv_callback = sub (hash<auto> h) {
                if (h.hdr) {
                    rhdr = h.hdr;
                    if (h.hdr."transfer-encoding" == "chunked") {
                        chunked = True;
                    } else if (h.send_aborted) {
                        send_aborted = True;
                    }
                }
                # call DataStream callback
                dsrecv_callback(h);
            };

            # issue #3237: make sure to send the response-code key in all cases
            on_exit if (rhdr.status_code) {
                info."response-code" = rhdr.status_code;
            }

            sendWithRecvCallback(recv_callback, body, m, path, hdr, 60s, False, \info);

            # we can get a binary response if we received a chunked non-DataStream message
            # in which case we need to decode it here (issue 1438)
            if (rrs.typeCode() == NT_BINARY) {
                *string ce;
                *string ct;
                if (chunked) {
                    ct = rhdr{DataStreamContentType.lwr()} ?? rhdr."content-type";
                    ce = rhdr{DataStreamContentEncoding.lwr()} ?? rhdr."content-encoding";
                } else {
                    ct = rhdr."content-type";
                    ce = rhdr."content-encoding";
                }
                if (ce) {
                    rrs = ds_get_content_decode(ce)(rrs, "utf8");
                }
                if (rmd.typeCode() == NT_STRING && ct) {
                    *hash<auto> ddc = DataStreamDeserializationSupport{ct};
                    if (ddc) {
                        rmd = ddc.in(rrs);
                    }
                }
            }

            if (send_aborted) {
                throw "SEND-ABORTED", sprintf("receiver returned status code %d while sending chunked data; send was "
                    "aborted", rhdr.status_code), ("hdr": rhdr, "data": rmd);
            }

            hash<auto> rv = rhdr + {"body": rmd};
            bool datastream = chunked && rhdr.hasKey(DataStreamContentType.lwr());
            if (!datastream) {
                rv = processRestResponse(rv, m, path, \info);
            }

            # rethrow exceptions returned from the sender
            if (rv.status_code >= 300 && !getErrorPassthru()) {
                if (rv.body.err && rv.body.desc) {
                    if (decode_errors && rv.body.arg.body) {
                        decodeError(rv.body.arg, \info);
                    }
                    throw rv.body.err, rv.body.desc, rv.body.arg;
                }
                throw "DATASTREAM-CLIENT-RECEIVE-ERROR", sprintf("HTTP status code %d received: message: %y",
                    rhdr.status_code, rhdr.status_message), rv;
            }

            return rv;
        }
    }
}
